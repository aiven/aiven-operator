// Code generated by user config generator. DO NOT EDIT.
// +kubebuilder:object:generate=true

package clickhousekafkauserconfig

// Table column
type Columns struct {
	// +kubebuilder:validation:MinLength=1
	// +kubebuilder:validation:MaxLength=40
	// The name of the column in the ClickHouse table. This should match the field names in your Kafka message format.
	Name string `groups:"create,update" json:"name"`

	// +kubebuilder:validation:MinLength=1
	// +kubebuilder:validation:MaxLength=1000
	// The ClickHouse data type for this column. Must be a valid ClickHouse data type that can handle the data format.
	Type string `groups:"create,update" json:"type"`
}

// Kafka topic
type Topics struct {
	// +kubebuilder:validation:MinLength=1
	// +kubebuilder:validation:MaxLength=249
	// The name of the Kafka topic to read messages from or write messages to. The topic must exist in the Kafka cluster.
	Name string `groups:"create,update" json:"name"`
}

// Table to create
type Tables struct {
	// +kubebuilder:validation:Enum="beginning";"earliest";"end";"largest";"latest";"smallest"
	// Determines where to start reading from Kafka when no offset is stored or the stored offset is out of range. 'earliest' starts from the beginning, 'latest' starts from the end.
	AutoOffsetReset *string `groups:"create,update" json:"auto_offset_reset,omitempty"`

	// +kubebuilder:validation:MaxItems=100
	// Array of column definitions that specify the structure of the ClickHouse table. Each column maps to a field in the Kafka messages.
	Columns []*Columns `groups:"create,update" json:"columns"`

	// +kubebuilder:validation:Enum="Avro";"AvroConfluent";"CSV";"JSONAsString";"JSONCompactEachRow";"JSONCompactStringsEachRow";"JSONEachRow";"JSONStringsEachRow";"MsgPack";"Parquet";"RawBLOB";"TSKV";"TSV";"TabSeparated"
	// The format of the messages in the Kafka topics. Determines how ClickHouse parses and serializes the data (e.g., JSON, CSV, Avro).
	DataFormat string `groups:"create,update" json:"data_format"`

	// +kubebuilder:validation:Enum="basic";"best_effort";"best_effort_us"
	// Specifies how ClickHouse should parse DateTime values from text-based input formats. 'basic' uses simple parsing, 'best_effort' attempts more flexible parsing.
	DateTimeInputFormat *string `groups:"create,update" json:"date_time_input_format,omitempty"`

	// +kubebuilder:validation:MinLength=1
	// +kubebuilder:validation:MaxLength=249
	// The Kafka consumer group name. Multiple consumers with the same group name will share the workload and maintain offset positions.
	GroupName string `groups:"create,update" json:"group_name"`

	// +kubebuilder:validation:Enum="default";"stream"
	// Defines how ClickHouse should handle errors when processing Kafka messages. 'default' stops on errors, 'stream' continues processing and logs errors.
	HandleErrorMode *string `groups:"create,update" json:"handle_error_mode,omitempty"`

	// +kubebuilder:validation:Minimum=0
	// +kubebuilder:validation:Maximum=1000000000
	// Maximum number of rows to collect before flushing data between Kafka and ClickHouse.
	MaxBlockSize *int `groups:"create,update" json:"max_block_size,omitempty"`

	// +kubebuilder:validation:Minimum=1
	// +kubebuilder:validation:Maximum=1000000000
	// Maximum number of rows that can be processed from a single Kafka message for row-based formats. Useful for controlling memory usage.
	MaxRowsPerMessage *int `groups:"create,update" json:"max_rows_per_message,omitempty"`

	// +kubebuilder:validation:MinLength=1
	// +kubebuilder:validation:MaxLength=40
	// The name of the ClickHouse table to be created. This table can consume data from and write data to the specified Kafka topics.
	Name string `groups:"create,update" json:"name"`

	// +kubebuilder:validation:Minimum=1
	// +kubebuilder:validation:Maximum=10
	// Number of Kafka consumers to run per table per replica. Increasing this can improve throughput but may increase resource usage.
	NumConsumers *int `groups:"create,update" json:"num_consumers,omitempty"`

	// +kubebuilder:validation:Minimum=0
	// +kubebuilder:validation:Maximum=1000000000
	// Maximum number of messages to fetch in a single Kafka poll operation for reading.
	PollMaxBatchSize *int `groups:"create,update" json:"poll_max_batch_size,omitempty"`

	// +kubebuilder:validation:Minimum=0
	// +kubebuilder:validation:Maximum=30000
	// Timeout in milliseconds for a single poll from Kafka. Takes the value of the stream_flush_interval_ms server setting by default (500ms).
	PollMaxTimeoutMs *int `groups:"create,update" json:"poll_max_timeout_ms,omitempty"`

	// +kubebuilder:validation:Minimum=1
	// +kubebuilder:validation:Maximum=1000000
	// The maximum number of messages in a batch sent to Kafka. If the number of messages exceeds this value, the batch is sent.
	ProducerBatchNumMessages *int `groups:"create,update" json:"producer_batch_num_messages,omitempty"`

	// +kubebuilder:validation:Minimum=0
	// +kubebuilder:validation:Maximum=2147483647
	// The maximum size in bytes of a batch of messages sent to Kafka. If the batch size is exceeded, the batch is sent.
	ProducerBatchSize *int `groups:"create,update" json:"producer_batch_size,omitempty"`

	// +kubebuilder:validation:Enum="gzip";"lz4";"none";"snappy";"zstd"
	// The compression codec to use when sending a batch of messages to Kafka.
	ProducerCompressionCodec *string `groups:"create,update" json:"producer_compression_codec,omitempty"`

	// +kubebuilder:validation:Minimum=-1
	// +kubebuilder:validation:Maximum=12
	// The compression level to use when sending a batch of messages to Kafka. Usable range is algorithm-dependent: [0-9] for gzip; [0-12] for lz4; only 0 for snappy; -1 = codec-dependent default compression level.
	ProducerCompressionLevel *int `groups:"create,update" json:"producer_compression_level,omitempty"`

	// +kubebuilder:validation:Minimum=0
	// +kubebuilder:validation:Maximum=900000
	// The time in milliseconds to wait for additional messages before sending a batch. If the time is exceeded, the batch is sent.
	ProducerLingerMs *int `groups:"create,update" json:"producer_linger_ms,omitempty"`

	// +kubebuilder:validation:Minimum=0
	// +kubebuilder:validation:Maximum=2147483647
	// The maximum size of the buffer in kilobytes before sending
	ProducerQueueBufferingMaxKbytes *int `groups:"create,update" json:"producer_queue_buffering_max_kbytes,omitempty"`

	// +kubebuilder:validation:Minimum=0
	// +kubebuilder:validation:Maximum=2147483647
	// The maximum number of messages to buffer before sending
	ProducerQueueBufferingMaxMessages *int `groups:"create,update" json:"producer_queue_buffering_max_messages,omitempty"`

	// +kubebuilder:validation:Minimum=-1
	// +kubebuilder:validation:Maximum=1000
	// The number of acknowledgements the leader broker must receive from ISR brokers before responding to the request: 0=Broker does not send any response/ack to client, -1 will block until message is committed by all in sync replicas (ISRs).
	ProducerRequestRequiredAcks *int `groups:"create,update" json:"producer_request_required_acks,omitempty"`

	// +kubebuilder:validation:Minimum=0
	// +kubebuilder:validation:Maximum=1000000000
	// Number of broken messages to skip before stopping processing when reading from Kafka. Useful for handling corrupted data without failing the entire integration.
	SkipBrokenMessages *int `groups:"create,update" json:"skip_broken_messages,omitempty"`

	// When enabled, each consumer runs in its own thread, providing better isolation and potentially better performance for high-throughput scenarios.
	ThreadPerConsumer *bool `groups:"create,update" json:"thread_per_consumer,omitempty"`

	// +kubebuilder:validation:MaxItems=100
	// Array of Kafka topics that this table will read data from or write data to. Messages from all specified topics will be inserted into this table, and data inserted into this table will be published to the topics.
	Topics []*Topics `groups:"create,update" json:"topics"`
}

// Integration user config
type ClickhouseKafkaUserConfig struct {
	// +kubebuilder:validation:MaxItems=400
	// Array of table configurations that define how Kafka topics are mapped to ClickHouse tables. Each table configuration specifies the table structure, associated Kafka topics, and read/write settings.
	Tables []*Tables `groups:"create,update" json:"tables,omitempty"`
}
