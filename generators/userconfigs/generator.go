package main

import (
	"errors"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strings"

	"github.com/dave/jennifer/jen"
	"github.com/goccy/go-yaml"
	"github.com/google/go-cmp/cmp"
	"github.com/stoewer/go-strcase"
	"golang.org/x/exp/slices"
	"golang.org/x/tools/imports"
)

var errUnknownType = errors.New("unknown type")

// generate writes to file a service user config for a given serviceList
func generate(dstDir string, serviceTypes []byte, serviceList []string) error {
	// root level object
	var root map[string]*object

	err := yaml.Unmarshal(serviceTypes, &root)
	if err != nil {
		return err
	}

	done := make([]string, 0, len(serviceList))
	for _, k := range serviceList {
		v, ok := root[k]
		if !ok {
			continue
		}

		dirPath := filepath.Join(dstDir, k)
		err = os.MkdirAll(dirPath, os.ModePerm)
		if err != nil {
			return err
		}

		b, err := newUserConfigFile(k, v)
		if err != nil {
			log.Println(err)
			continue
		}

		filePath := filepath.Join(dirPath, k+".go")
		err = os.WriteFile(filePath, b, 0o644)
		if err != nil {
			return err
		}

		if slices.Contains(done, k) {
			return fmt.Errorf("%q is a duplicate name on the list", k)
		}
		done = append(done, k)
	}

	if d := cmp.Diff(serviceList, done); d != "" {
		return fmt.Errorf("not all services are generated: %s", d)
	}
	return nil
}

// newUserConfigFile generates jennifer file from the root object
func newUserConfigFile(name string, obj *object) ([]byte, error) {
	// User config has UserConfig suffix
	configName := name + "_user_config"
	root := toCamelCase(configName)
	obj.init(root) // Cascade init from the top

	// Package naming convention doesn't allow snake case
	packageName := strings.ReplaceAll(strings.ToLower(configName), "_", "")

	// packageName won't be used as a file name, as we return its data, not dumping to disk
	pack := jen.NewFile(packageName)
	pack.HeaderComment("Code generated by user config generator. DO NOT EDIT.")

	// Makes kubebuilder generate DeepCopy method for the package
	pack.HeaderComment("// +kubebuilder:object:generate=true")
	err := addObject(pack, obj)
	if err != nil {
		return nil, err
	}

	// Jenifer won't use imports from code chunks added with Op()
	// Even calling explicit import won't work,
	// cause if module is not used, then it's dropped
	// Calls goimports which fixes missing imports
	b, err := imports.Process("", []byte(pack.GoString()), nil)
	if err != nil {
		return nil, err
	}

	return b, nil
}

// objectType json object types
type objectType string

const (
	objectTypeObject  objectType = "object"
	objectTypeArray   objectType = "array"
	objectTypeString  objectType = "string"
	objectTypeBoolean objectType = "boolean"
	objectTypeInteger objectType = "integer"
	objectTypeNumber  objectType = "number"
)

// object represents OpenApi object
type object struct {
	jsonName      string   // original name from json spec
	structName    string   // go struct name in CamelCase
	propertyNames []string // properties with order

	IsDeprecated bool `yaml:"is_deprecated"`
	Enum         []*struct {
		Value        string `yaml:"value"`
		IsDeprecated bool   `yaml:"is_deprecated"`
	} `yaml:"enum"`
	Pattern   string `yaml:"pattern"`
	MinItems  *int   `yaml:"min_items"`
	MaxItems  *int   `yaml:"max_items"`
	MinLength *int   `yaml:"min_length"`
	MaxLength *int   `yaml:"max_length"`
	// Store both int and float
	Minimum *float64 `yaml:"minimum"`
	Maximum *float64 `yaml:"maximum"`

	// OpenAPI Spec
	Type           objectType         `yaml:"-"`
	OrigType       interface{}        `yaml:"type"`
	Format         string             `yaml:"format"`
	Title          string             `yaml:"title"`
	Description    string             `yaml:"description"`
	Properties     map[string]*object `yaml:"properties"`
	ArrayItems     *object            `yaml:"items"`
	RequiredFields []string           `yaml:"required"`
	CreateOnly     bool               `yaml:"create_only"`
	Required       bool               `yaml:"-"`
	// Go doesn't support nullable scalar types, e.g.:
	// type Foo struct {
	//     Foo *bool `json:"foo,omitempty"
	// }
	// To be able to send "false" we use pointer. So "nil" becomes "empty"
	// Then if we need to send "nil", we remove "omitempty"
	//     Foo *bool `json:"foo"
	// Now it is possible to send [null, true, false]
	// But the field becomes required, and it's mandatory to have it manifest
	// We can mark field as "optional" for builder:
	//     // +optional
	//     Foo *bool `json:"foo,omitempty"
	// That means that KubeAPI won't require this field on request.
	// But that would send explicit "nil" to Aiven API.
	// Now you need "default" value to send it instead of "nil", if default is not nil.
	// Adding `+nullable` will fail on API call for the same reason (pointer vs omitempty vs default value)
	// Another reason is that spec is mostly invalid, and nullable fields are not so.
	// So for simplicity this generator doesn't support nullable values.
	Nullable bool `yaml:"-"` // Not really used for now
}

// init initiates object after it gets values from OpenAPI spec
func (o *object) init(name string) {
	o.jsonName = name
	o.structName = toCamelCase(name)

	// Sorts properties, so they keep order on each generation
	keys := make([]string, 0, len(o.Properties))
	for k := range o.Properties {
		keys = append(keys, k)
	}
	slices.Sort(keys)
	o.propertyNames = keys

	required := make(map[string]bool, len(o.RequiredFields))
	for _, k := range o.RequiredFields {
		required[k] = true
	}

	for _, k := range keys {
		child := o.Properties[k]
		child.Required = required[k]
		child.init(k)
	}

	if o.ArrayItems != nil {
		o.ArrayItems.init(name)
		// Slice items always Required, but for GO struct pointers are better
		o.ArrayItems.Required = o.ArrayItems.Type != objectTypeObject
		// Slice items can't be null, if so it is invalid spec
		o.ArrayItems.Nullable = false
	}

	// Types can be list of strings, or a string
	if v, ok := o.OrigType.(string); ok {
		o.Type = objectType(v)
	} else if v, ok := o.OrigType.([]interface{}); ok {
		o.Type = objectType(v[0].(string))
		for _, t := range v {
			switch s := t.(string); s {
			case "null":
				// Enums can't be nullable
				o.Nullable = len(o.Enum) == 0
			case "":
			//	Ignores invalid type
			default:
				// Prioritizes the object type.
				// Usually it starts with a scalar type, and then mutates to object.
				if o.Type != objectTypeObject {
					o.Type = objectType(s)
				}
			}
		}
	}
}

// isVersionField returns true if this field is a version field (e.g., pg_version, kafka_version).
func (o *object) isVersionField() bool {
	return strings.HasSuffix(o.jsonName, "_version")
}

// addObject adds object to jen.File
func addObject(file *jen.File, obj *object) error {
	fields := make([]jen.Code, len(obj.propertyNames))
	for i, key := range obj.propertyNames {
		child := obj.Properties[key]
		f, err := addField(file, jen.Id(child.structName), child)
		if errors.Is(err, errUnknownType) {
			if child.Required {
				return fmt.Errorf("%q is required: %w", child.jsonName, err)
			}
			log.Printf("skipping optional field %q: %s", child.jsonName, err)
			continue
		}
		if err != nil {
			return fmt.Errorf("can't add field %q: %w", key, err)
		}
		fields[i] = f
	}

	// Creates struct and adds fmtComment if available
	s := jen.Type().Id(obj.structName).Struct(fields...)
	if c := fmtComment(obj); c != "" {
		s = jen.Comment(fmtComment(obj)).Line().Add(s)
	}

	file.Add(s)
	return nil
}

func addField(file *jen.File, s *jen.Statement, obj *object) (*jen.Statement, error) {
	s, err := addFieldType(file, s, obj)
	if err != nil {
		return nil, err
	}

	s = addFieldComments(s, obj)
	s = addFieldTags(s, obj)
	return s.Line(), nil
}

func addFieldType(file *jen.File, s *jen.Statement, obj *object) (*jen.Statement, error) {
	if !obj.Required {
		// Adds to all types, except arrays, which are of pointer type in go
		if obj.Type != objectTypeArray {
			s = s.Op("*")
		}
	}

	switch obj.Type {
	case objectTypeObject:
		err := addObject(file, obj)
		if err != nil {
			return nil, err
		}
		s = s.Id(obj.structName)
	case objectTypeArray:
		return addFieldType(file, s.Index(), obj.ArrayItems)
	case objectTypeString:
		s = s.String()
	case objectTypeBoolean:
		s = s.Bool()
	case objectTypeInteger:
		s = s.Int()
	case objectTypeNumber:
		s = s.Float64()
	default:
		return nil, errUnknownType
	}
	return s, nil
}

// addFieldTags adds tags for marshal/unmarshal
// with `groups` tag it is possible to mark "create only" fields, like `admin_password`
func addFieldTags(s *jen.Statement, obj *object) *jen.Statement {
	tags := map[string]string{
		"json":   obj.jsonName,
		"groups": "create",
	}

	if !obj.Required {
		tags["json"] += ",omitempty"
	}

	// CreatOnly can't be updated
	if !obj.CreateOnly {
		tags["groups"] += ",update"
	}
	return s.Tag(tags)
}

// supportLastDeprecatedEnum allows to run services with deprecated values
const supportLastDeprecatedEnum = 1

// addFieldComments add validation markers and doc string
func addFieldComments(s *jen.Statement, obj *object) *jen.Statement {
	c := make([]string, 0)

	// Sets min-max if they are not equal (both empty or equal to zero)
	minValue := objMinimum(obj)
	maxValue := objMaximum(obj)
	if minValue != maxValue {
		if minValue != "" {
			c = append(c, "// +kubebuilder:validation:Minimum="+minValue)
		}
		if maxValue != "" {
			c = append(c, "// +kubebuilder:validation:Maximum="+maxValue)
		}
	}

	if obj.MinLength != nil {
		c = append(c, fmt.Sprintf("// +kubebuilder:validation:MinLength=%d", *obj.MinLength))
	}
	if obj.MaxLength != nil {
		c = append(c, fmt.Sprintf("// +kubebuilder:validation:MaxLength=%d", *obj.MaxLength))
	}
	if obj.MinItems != nil {
		c = append(c, fmt.Sprintf("// +kubebuilder:validation:MinItems=%d", *obj.MinItems))
	}
	if obj.MaxItems != nil {
		c = append(c, fmt.Sprintf("// +kubebuilder:validation:MaxItems=%d", *obj.MaxItems))
	}
	if obj.Pattern != "" {
		_, err := regexp.Compile(obj.Pattern)
		if err != nil {
			log.Printf("can't compile field %q regex `%s`: %s", obj.jsonName, obj.Pattern, err)
		} else {
			c = append(c, fmt.Sprintf("// +kubebuilder:validation:Pattern=`%s`", obj.Pattern))
		}
	}

	deprecatedEnums := make([]string, 0)
	if len(obj.Enum) != 0 {
		sort.Slice(obj.Enum, func(i, j int) bool {
			return obj.Enum[i].Value < obj.Enum[j].Value
		})

		enum := make([]string, 0, len(obj.Enum))
		for _, e := range obj.Enum {
			if e.IsDeprecated {
				// This is kafka_version or pg_version, etc.
				// We allow to use supportLastDeprecatedEnum so customers can migrate their services
				deprecatedEnums = append(deprecatedEnums, fmt.Sprintf("`%s`", e.Value))
			}
			v := e.Value
			if obj.Type == objectTypeString {
				v = fmt.Sprintf("%q", e.Value)
			}
			enum = append(enum, v)
		}

		if len(enum) != 0 {
			enum = enum[max(0, len(deprecatedEnums)-supportLastDeprecatedEnum):]
			if obj.isVersionField() {
				comments := make([]string, len(enum))
				for i, v := range enum {
					comments[i] = fmt.Sprintf("`%s`", strings.Trim(v, `"`))
				}
				c = append(c, "// Available versions: "+strings.Join(comments, ", ")+". Newer versions may also be available.")
			} else {
				c = append(c, fmt.Sprintf("// +kubebuilder:validation:Enum=%s", strings.Join(enum, ";")))
			}
		}
	}

	if obj.CreateOnly {
		c = append(c, `// +kubebuilder:validation:XValidation:rule="self == oldSelf",message="Value is immutable"`)
	}

	if obj.IsDeprecated {
		c = append(c, fmt.Sprintf(`// +kubebuilder:deprecatedversion:warning="%s is deprecated"`, obj.jsonName))
	}

	// Starts formatting the comment
	doc := fmtComment(obj)

	// Adds deprecated values to the comment
	if !obj.IsDeprecated && len(deprecatedEnums) > 0 {
		deprecatedEnums = deprecatedEnums[max(0, len(deprecatedEnums)-supportLastDeprecatedEnum):]
		doc = fmt.Sprintf("%s. Deprecated values: %s", strings.TrimSuffix(doc, "."), strings.Join(deprecatedEnums, ", "))
	}

	if doc != "" {
		c = append(c, doc)
	}

	if len(c) != 0 {
		s = jen.Comment(strings.Join(c, "\n")).Line().Add(s)
	}

	return s
}

// fmtComment creates nice comment from object.Title or object.Description (takes the longest string)
func fmtComment(obj *object) string {
	d := ""
	if len(obj.Description) > len(obj.Title) {
		d = obj.Description
	} else {
		d = obj.Title
	}

	if obj.IsDeprecated {
		d = "Deprecated. " + d
	}

	if d == "" {
		return d
	}
	// Do not add field/struct name into the comment.
	// Otherwise, generated manifests and docs will have those as a part of the description
	return strings.ReplaceAll("// "+d, "\n", " ")
}

// toCamelCase some fields has dots within, makes cleaner camelCase
func toCamelCase(s string) string {
	return strcase.UpperCamelCase(strings.ReplaceAll(s, ".", "_"))
}

// maxSafeInt float64 mantissa size is 53 bits (52 explicitly stored) - 1
// - Can be exactly represented as an IEEE-754 double precision number, and
// - IEEE-754 representation cannot be the result of rounding any other integer to fit the IEEE-754 representation.
const maxSafeInt = float64(1<<53 - 1)

func objMaximum(obj *object) string {
	if obj.Maximum == nil {
		return ""
	}

	f := *obj.Maximum
	if f > maxSafeInt {
		return ""
	}

	if obj.Type == objectTypeInteger {
		return fmt.Sprint(int(f))
	}
	return fmt.Sprint(f)
}

func objMinimum(obj *object) string {
	if obj.Minimum == nil {
		return ""
	}

	f := *obj.Minimum
	if f < -maxSafeInt {
		return ""
	}

	if obj.Type == objectTypeInteger {
		return fmt.Sprint(int(f))
	}
	return fmt.Sprint(f)
}
